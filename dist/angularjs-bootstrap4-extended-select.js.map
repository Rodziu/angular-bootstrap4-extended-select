{"version":3,"sources":["webpack://extendedSelect/webpack/universalModuleDefinition","webpack://extendedSelect/./.build/src/ts/lib/component/es-transclude.directive.ts","webpack://extendedSelect/./.build/lib/component/lib/component/es-transclude.directive.js","webpack://extendedSelect/./.build/src/ts/lib/component/extended-select-mark-result.component.ts","webpack://extendedSelect/./.build/lib/component/lib/component/extended-select-mark-result.component.js","webpack://extendedSelect/./.build/src/ts/lib/component/extended-select-option-group.component.ts","webpack://extendedSelect/./.build/lib/component/lib/component/extended-select-option-group.component.js","webpack://extendedSelect/./.build/src/ts/lib/component/extended-select-options.directive.ts","webpack://extendedSelect/./.build/lib/component/lib/component/extended-select-options.directive.js","webpack://extendedSelect/./.build/src/ts/lib/component/extended-select-search.directive.ts","webpack://extendedSelect/./.build/lib/component/lib/component/extended-select-search.directive.js","webpack://extendedSelect/./.build/src/ts/lib/component/extended-select.component.ts","webpack://extendedSelect/./.build/lib/component/lib/component/extended-select.component.js","webpack://extendedSelect/./src/ts/lib/extended-select.config.ts","webpack://extendedSelect/./.build/lib/lib/extended-select.config.js","webpack://extendedSelect/./src/ts/lib/extended-select.module.ts","webpack://extendedSelect/./.build/lib/lib/extended-select.module.js","webpack://extendedSelect/./src/ts/lib/extended-select.provider.ts","webpack://extendedSelect/./.build/lib/lib/extended-select.provider.js","webpack://extendedSelect/./.build/src/ts/lib/service/extended-select-options.service.ts","webpack://extendedSelect/./.build/lib/service/lib/service/extended-select-options.service.js","webpack://extendedSelect/external \"angular\"","webpack://extendedSelect/external \"angularjs-bootstrap-4\"","webpack://extendedSelect/webpack/bootstrap","webpack://extendedSelect/webpack/runtime/compat get default export","webpack://extendedSelect/webpack/runtime/define property getters","webpack://extendedSelect/webpack/runtime/hasOwnProperty shorthand","webpack://extendedSelect/webpack/runtime/make namespace object","webpack://extendedSelect/../src/ts/angularjs-bootstrap4-extended-select.ts","webpack://extendedSelect/./.build/angularjs-bootstrap4-extended-select.js"],"names":[],"mappings":"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","file":"angularjs-bootstrap4-extended-select.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"), require(\"angularjs-bootstrap-4\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"angularjs-bootstrap4-extended-select\", [\"angular\", \"angularjs-bootstrap-4\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"angularjs-bootstrap4-extended-select\"] = factory(require(\"angular\"), require(\"angularjs-bootstrap-4\"));\n\telse\n\t\troot[\"angularjs-bootstrap4-extended-select\"] = factory(root[\"angular\"], root[\"angularjs-bootstrap-4\"]);\n})(window, function(__WEBPACK_EXTERNAL_MODULE_angular__, __WEBPACK_EXTERNAL_MODULE_angularjs_bootstrap_4__) {\nreturn ","/*\n * AngularJS extended select component.\n * Copyright (c) 2016-2021 Rodziu <mateusz.rohde@gmail.com>\n * License: MIT\n */\n\nimport {IDirective, IScope} from 'angular';\nimport * as angular from 'angular';\nimport {ExtendedSelectComponentController, IExtendedSelectOption} from './extended-select.component';\n\ninterface IEsTranscludeScope extends IScope {\n    $extendedSelect: ExtendedSelectComponentController,\n    $option: IExtendedSelectOption,\n    $isOption: boolean\n}\n\nexport function esTranscludeDirective(): IDirective {\n    /**\n     * @ngdoc directive\n     * @name esTransclude\n     */\n    return {\n        restrict: 'A',\n        require: '^extendedSelect',\n        link: function(\n            scope,\n            element,\n            attrs,\n            ctrl: ExtendedSelectComponentController,\n            transclude\n        ) {\n            const slots = attrs['esTransclude'] ? [attrs['esTransclude']] : ['optionTemplate', 'beforeOption'];\n            slots.forEach((slot) => {\n                if (transclude.isSlotFilled(slot)) {\n                    transclude((clone, transcludedScope: IEsTranscludeScope) => {\n                        transcludedScope.$extendedSelect = ctrl;\n                        transcludedScope.$option = scope['o'];\n                        transcludedScope.$isOption = true;\n                        if (angular.isUndefined(scope['o'])) {\n                            transcludedScope.$isOption = false;\n                            if (ctrl.multiple) {\n                                transcludedScope.$option = {\n                                    value: scope['m'],\n                                    label: ctrl.getModelLabel(scope['m'])\n                                };\n                            } else {\n                                transcludedScope.$watch(() => {\n                                    return ctrl.ngModel;\n                                }, () => {\n                                    transcludedScope.$option = {\n                                        value: ctrl.ngModel,\n                                        label: ctrl.getModelLabel()\n                                    };\n                                });\n                            }\n                        }\n                        if (slot === 'optionTemplate') {\n                            element.contents().replaceWith(clone);\n                        } else {\n                            element.prepend(clone);\n                        }\n                    }, null, slot);\n                }\n            });\n        }\n    }\n}\n","/*\n * AngularJS extended select component.\n * Copyright (c) 2016-2021 Rodziu <mateusz.rohde@gmail.com>\n * License: MIT\n */\nimport * as angular from 'angular';\nexport function esTranscludeDirective() {\n    /**\n     * @ngdoc directive\n     * @name esTransclude\n     */\n    return {\n        restrict: 'A',\n        require: '^extendedSelect',\n        link: function (scope, element, attrs, ctrl, transclude) {\n            const slots = attrs['esTransclude'] ? [attrs['esTransclude']] : ['optionTemplate', 'beforeOption'];\n            slots.forEach((slot) => {\n                if (transclude.isSlotFilled(slot)) {\n                    transclude((clone, transcludedScope) => {\n                        transcludedScope.$extendedSelect = ctrl;\n                        transcludedScope.$option = scope['o'];\n                        transcludedScope.$isOption = true;\n                        if (angular.isUndefined(scope['o'])) {\n                            transcludedScope.$isOption = false;\n                            if (ctrl.multiple) {\n                                transcludedScope.$option = {\n                                    value: scope['m'],\n                                    label: ctrl.getModelLabel(scope['m'])\n                                };\n                            }\n                            else {\n                                transcludedScope.$watch(() => {\n                                    return ctrl.ngModel;\n                                }, () => {\n                                    transcludedScope.$option = {\n                                        value: ctrl.ngModel,\n                                        label: ctrl.getModelLabel()\n                                    };\n                                });\n                            }\n                        }\n                        if (slot === 'optionTemplate') {\n                            element.contents().replaceWith(clone);\n                        }\n                        else {\n                            element.prepend(clone);\n                        }\n                    }, null, slot);\n                }\n            });\n        }\n    };\n}\n","/*\n * AngularJS extended select component.\n * Copyright (c) 2016-2021 Rodziu <mateusz.rohde@gmail.com>\n * License: MIT\n */\n\nimport {ExtendedSelectComponentController} from './extended-select.component';\nimport * as angular from 'angular';\nimport {IComponentOptions} from 'angular';\n\n/**\n * @ngInject\n */\nclass ExtendedSelectMarkResultComponentController {\n    extendedSelect: ExtendedSelectComponentController;\n    label: string;\n    private _search: string;\n\n    constructor(\n        private $element: JQLite\n    ) {\n    }\n\n    $doCheck(): void {\n        if (this.extendedSelect.search !== this._search) {\n            this._update();\n        }\n    }\n\n    $onChanges(): void {\n        this._update();\n    }\n\n    private _update() {\n        this._search = this.extendedSelect.search;\n        let html = this.label;\n        if (this.label && angular.isString(this._search) && this._search.length) {\n            html = this.label.replace(new RegExp('(' + this._search + ')', 'gi'), '<u>$1</u>')\n        }\n        this.$element.html(html);\n    }\n}\n\n/**\n * @ngdoc component\n * @name extendedSelectMarkResult\n * @param {expression} label\n */\nexport const extendedSelectMarkResultComponent: IComponentOptions = {\n    require: {\n        extendedSelect: '^extendedSelect'\n    },\n    bindings: {\n        label: '<'\n    },\n    controllerAs: 'vm',\n    controller: ExtendedSelectMarkResultComponentController\n}\n","/*\n * AngularJS extended select component.\n * Copyright (c) 2016-2021 Rodziu <mateusz.rohde@gmail.com>\n * License: MIT\n */\nimport * as angular from 'angular';\n/**\n * @ngInject\n */\nclass ExtendedSelectMarkResultComponentController {\n    constructor($element) {\n        this.$element = $element;\n    }\n    $doCheck() {\n        if (this.extendedSelect.search !== this._search) {\n            this._update();\n        }\n    }\n    $onChanges() {\n        this._update();\n    }\n    _update() {\n        this._search = this.extendedSelect.search;\n        let html = this.label;\n        if (this.label && angular.isString(this._search) && this._search.length) {\n            html = this.label.replace(new RegExp('(' + this._search + ')', 'gi'), '<u>$1</u>');\n        }\n        this.$element.html(html);\n    }\n}\n/**\n * @ngdoc component\n * @name extendedSelectMarkResult\n * @param {expression} label\n */\nexport const extendedSelectMarkResultComponent = {\n    require: {\n        extendedSelect: '^extendedSelect'\n    },\n    bindings: {\n        label: '<'\n    },\n    controllerAs: 'vm',\n    controller: ExtendedSelectMarkResultComponentController\n};\n","/*\n * AngularJS extended select component.\n * Copyright (c) 2016-2021 Rodziu <mateusz.rohde@gmail.com>\n * License: MIT\n */\n\n\nimport {IGroupItem} from './extended-select.component';\nimport * as angular from 'angular';\nimport {IComponentOptions} from 'angular';\n\n/**\n * @ngInject\n */\nclass ExtendedSelectOptionGroupController {\n    // bindings\n    group: IGroupItem;\n    prevGroup: IGroupItem;\n    //\n    groups: IGroupItem[];\n\n    $onChanges(): void {\n        this.groups = [this.group];\n        let group = this.group;\n        while (angular.isDefined(group.parent)) {\n            group = group.parent;\n            if (\n                angular.isDefined(this.prevGroup)\n            ) {\n                let commonAncestor = this.prevGroup;\n                if (commonAncestor.level > group.level) {\n                    commonAncestor = this.getUntilLevel(commonAncestor, group.level);\n                }\n                if (commonAncestor.name === group.name) {\n                    break;\n                }\n            }\n            this.groups.unshift(group);\n        }\n    }\n\n    getUntilLevel(group: IGroupItem, level: number): IGroupItem {\n        while (group.level > level) {\n            group = group.parent;\n        }\n        return group;\n    }\n}\nexport const extendedSelectOptionGroupComponent: IComponentOptions = {\n    controller: ExtendedSelectOptionGroupController,\n    controllerAs: 'vm',\n    bindings: {\n        group: '<',\n        prevGroup: '<'\n    },\n    template: '<h6 class=\"dropdown-header\" ng-repeat=\"group in vm.groups\" '\n        + 'ng-style=\"::{\\'padding-left\\': 10 + (group.level * 10) + \\'px\\'}\">{{::group.name}}</h6>'\n}\n","/*\n * AngularJS extended select component.\n * Copyright (c) 2016-2021 Rodziu <mateusz.rohde@gmail.com>\n * License: MIT\n */\nimport * as angular from 'angular';\n/**\n * @ngInject\n */\nclass ExtendedSelectOptionGroupController {\n    $onChanges() {\n        this.groups = [this.group];\n        let group = this.group;\n        while (angular.isDefined(group.parent)) {\n            group = group.parent;\n            if (angular.isDefined(this.prevGroup)) {\n                let commonAncestor = this.prevGroup;\n                if (commonAncestor.level > group.level) {\n                    commonAncestor = this.getUntilLevel(commonAncestor, group.level);\n                }\n                if (commonAncestor.name === group.name) {\n                    break;\n                }\n            }\n            this.groups.unshift(group);\n        }\n    }\n    getUntilLevel(group, level) {\n        while (group.level > level) {\n            group = group.parent;\n        }\n        return group;\n    }\n}\nexport const extendedSelectOptionGroupComponent = {\n    controller: ExtendedSelectOptionGroupController,\n    controllerAs: 'vm',\n    bindings: {\n        group: '<',\n        prevGroup: '<'\n    },\n    template: '<h6 class=\"dropdown-header\" ng-repeat=\"group in vm.groups\" '\n        + 'ng-style=\"::{\\'padding-left\\': 10 + (group.level * 10) + \\'px\\'}\">{{::group.name}}</h6>'\n};\n","/*\n * AngularJS extended select component.\n * Copyright (c) 2016-2021 Rodziu <mateusz.rohde@gmail.com>\n * License: MIT\n */\n\nimport {IDirective} from 'angular';\nimport {AngularBSService} from 'angularjs-bootstrap-4';\n\n/**\n * @ngInject\n */\nclass ExtendedSelectOptionsDirectiveController {\n    activeIndex: number;\n\n    constructor(\n        private $element: JQLite,\n        private angularBS: AngularBSService\n    ) {\n    }\n\n    $onChanges(): void { // it's always an activeIndex change\n        const item = this.$element[0].querySelector(\n            `.dropdown-item:nth-child(${this.activeIndex + 1})`\n        ) as HTMLDivElement;\n        if (item === null) {\n            return;\n        }\n        const top = item.offsetTop,\n            scroll = this.$element[0].scrollTop,\n            bot = this.angularBS.offset(item).height + top,\n            ulHeight = this.angularBS.offset(this.$element[0]).height;\n        if (scroll - top > 0) { // move it up\n            this.$element[0].scrollTop = top;\n        } else if (scroll - bot < ulHeight * -1) { // move it down\n            this.$element[0].scrollTop = bot - ulHeight;\n        }\n    }\n}\n\nexport function extendedSelectOptionsDirective(): IDirective {\n    /**\n     * @ngdoc directive\n     * @name extendedSelectOptions\n     * @description automatically scroll dropdown window to highlighted option\n     */\n    return {\n        restrict: 'A',\n        bindToController: {\n            activeIndex: '<extendedSelectOptions'\n        },\n        controller: ExtendedSelectOptionsDirectiveController\n    };\n}\n","/*\n * AngularJS extended select component.\n * Copyright (c) 2016-2021 Rodziu <mateusz.rohde@gmail.com>\n * License: MIT\n */\n/**\n * @ngInject\n */\nclass ExtendedSelectOptionsDirectiveController {\n    constructor($element, angularBS) {\n        this.$element = $element;\n        this.angularBS = angularBS;\n    }\n    $onChanges() {\n        const item = this.$element[0].querySelector(`.dropdown-item:nth-child(${this.activeIndex + 1})`);\n        if (item === null) {\n            return;\n        }\n        const top = item.offsetTop, scroll = this.$element[0].scrollTop, bot = this.angularBS.offset(item).height + top, ulHeight = this.angularBS.offset(this.$element[0]).height;\n        if (scroll - top > 0) { // move it up\n            this.$element[0].scrollTop = top;\n        }\n        else if (scroll - bot < ulHeight * -1) { // move it down\n            this.$element[0].scrollTop = bot - ulHeight;\n        }\n    }\n}\nexport function extendedSelectOptionsDirective() {\n    /**\n     * @ngdoc directive\n     * @name extendedSelectOptions\n     * @description automatically scroll dropdown window to highlighted option\n     */\n    return {\n        restrict: 'A',\n        bindToController: {\n            activeIndex: '<extendedSelectOptions'\n        },\n        controller: ExtendedSelectOptionsDirectiveController\n    };\n}\n","/*\n * AngularJS extended select component.\n * Copyright (c) 2016-2021 Rodziu <mateusz.rohde@gmail.com>\n * License: MIT\n */\n\nimport IInjectorService = angular.auto.IInjectorService;\nimport {IDirective} from 'angular';\nimport * as angular from 'angular';\n\n/**\n * @ngInject\n */\nexport function extendedSelectSearchDirective($injector: IInjectorService): IDirective {\n    /**\n     * @ngdoc directive\n     * @name extendedSelectSearch\n     * @description search element\n     */\n    return {\n        restrict: 'A',\n        require: '^extendedSelect',\n        link: function(scope, element, attrs, ctrl) {\n            if ($injector.has('$animate')) {\n                ($injector.get('$animate') as angular.animate.IAnimateService).enabled(element, false);\n            }\n            element[0].focus();\n            /**\n             * move selection or pick an option on keydown\n             */\n            element.on('keydown', function(e) {\n                e.stopPropagation();\n                if (!ctrl.optionsFiltered.length) {\n                    if (e.which === 13) {\n                        ctrl.addOptionAction();\n                        ctrl.$scope.$apply();\n                    }\n                    return;\n                }\n                const originalIndex = ctrl.activeIndex;\n                switch (e.which) {\n                    case 40: // down\n                        do {\n                            ctrl.activeIndex++;\n                            if (ctrl.activeIndex >= ctrl.optionsFiltered.length) {\n                                ctrl.activeIndex = originalIndex;\n                                break;\n                            }\n                        } while (ctrl.multiple && ctrl.isSelected(ctrl.optionsFiltered[ctrl.activeIndex]));\n                        break;\n                    case 38: // up\n                        do {\n                            ctrl.activeIndex--;\n                            if (ctrl.activeIndex < 0) {\n                                ctrl.activeIndex = originalIndex;\n                                break;\n                            }\n                        } while (ctrl.multiple && ctrl.isSelected(ctrl.optionsFiltered[ctrl.activeIndex]));\n                        break;\n                    case 13: // enter\n                        if (angular.isDefined(ctrl.optionsFiltered[ctrl.activeIndex])) {\n                            ctrl.pickOption(ctrl.optionsFiltered[ctrl.activeIndex]);\n                            ctrl.$scope.$apply();\n                            return;\n                        }\n                        break;\n                }\n                ctrl.$scope.$digest();\n            });\n        }\n    };\n}\n","/*\n * AngularJS extended select component.\n * Copyright (c) 2016-2021 Rodziu <mateusz.rohde@gmail.com>\n * License: MIT\n */\nimport * as angular from 'angular';\n/**\n * @ngInject\n */\nexport function extendedSelectSearchDirective($injector) {\n    /**\n     * @ngdoc directive\n     * @name extendedSelectSearch\n     * @description search element\n     */\n    return {\n        restrict: 'A',\n        require: '^extendedSelect',\n        link: function (scope, element, attrs, ctrl) {\n            if ($injector.has('$animate')) {\n                $injector.get('$animate').enabled(element, false);\n            }\n            element[0].focus();\n            /**\n             * move selection or pick an option on keydown\n             */\n            element.on('keydown', function (e) {\n                e.stopPropagation();\n                if (!ctrl.optionsFiltered.length) {\n                    if (e.which === 13) {\n                        ctrl.addOptionAction();\n                        ctrl.$scope.$apply();\n                    }\n                    return;\n                }\n                const originalIndex = ctrl.activeIndex;\n                switch (e.which) {\n                    case 40: // down\n                        do {\n                            ctrl.activeIndex++;\n                            if (ctrl.activeIndex >= ctrl.optionsFiltered.length) {\n                                ctrl.activeIndex = originalIndex;\n                                break;\n                            }\n                        } while (ctrl.multiple && ctrl.isSelected(ctrl.optionsFiltered[ctrl.activeIndex]));\n                        break;\n                    case 38: // up\n                        do {\n                            ctrl.activeIndex--;\n                            if (ctrl.activeIndex < 0) {\n                                ctrl.activeIndex = originalIndex;\n                                break;\n                            }\n                        } while (ctrl.multiple && ctrl.isSelected(ctrl.optionsFiltered[ctrl.activeIndex]));\n                        break;\n                    case 13: // enter\n                        if (angular.isDefined(ctrl.optionsFiltered[ctrl.activeIndex])) {\n                            ctrl.pickOption(ctrl.optionsFiltered[ctrl.activeIndex]);\n                            ctrl.$scope.$apply();\n                            return;\n                        }\n                        break;\n                }\n                ctrl.$scope.$digest();\n            });\n        }\n    };\n}\n","/*\n * AngularJS extended select component.\n * Copyright (c) 2016-2021 Rodziu <mateusz.rohde@gmail.com>\n * License: MIT\n */\n\nimport {\n    IAttributes,\n    IComponentOptions,\n    INgModelController,\n    IPromise,\n    IScope,\n    ITimeoutService,\n    ITranscludeFunction\n} from 'angular';\nimport {ExtendedSelectOptionsService, IParsedNgOptions} from '../service/extended-select-options.service';\nimport {IExtendedSelectOptions} from '../extended-select.provider';\nimport * as angular from 'angular';\n\nexport interface IGroupItem {\n    name: string,\n    parentGroup: string,\n    children: IGroupItem[],\n    level?: number,\n    parent?: IGroupItem\n}\n\nexport interface IExtendedSelectOption {\n    value: unknown,\n    label: string,\n    group?: IGroupItem\n}\n\n/**\n * @ngInject\n */\nexport class ExtendedSelectComponentController {\n    // bindings\n    ngModel: unknown | unknown[];\n    addOption: (locals: { value: string }) => void;\n    resolveOnSearch: (locals: { value: string, page: number }) => IPromise<{ hasNextPage?: boolean }>;\n    deselectable: boolean;\n    deselectValue: unknown;\n    typeToSearch: number;\n    searchByValue: boolean;\n    ngModelCtrl: INgModelController;\n    //\n    options: IExtendedSelectOption[] = [];\n    optionsFiltered: IExtendedSelectOption[] = [];\n    activeIndex = -1;\n    search = '';\n    multiple: boolean;\n    addOptionLang: string;\n    loadMoreResultsLang: string;\n    typeToSearchText: string;\n    placeholder: string;\n    isDisabled: boolean;\n    isReadonly: boolean;\n    isSmall: boolean;\n    isLarge: boolean;\n    isOpen: boolean;\n    hasNextPage: boolean;\n    page: number;\n    loading: boolean;\n    private _ngOptions: IParsedNgOptions;\n    private _searchTimeout = null;\n    private _optionObjects: Record<string, unknown>[];\n    private _addOptionCalled: boolean;\n    private _lastSearchValue: string;\n    private _transcludedOptions: IExtendedSelectOption[] = [];\n\n    constructor(\n        private $element: JQLite,\n        private $attrs: IAttributes,\n        private $scope: IScope,\n        private $timeout: ITimeoutService,\n        private $transclude: ITranscludeFunction,\n        private extendedSelectOptions: ExtendedSelectOptionsService,\n        private extendedSelect: IExtendedSelectOptions\n    ) {\n        this._ngOptions = 'ngOptions' in $attrs\n            ? extendedSelectOptions.parseNgOptions($attrs['ngOptions']) : null;\n        this.multiple = 'multiple' in this.$attrs;\n        this.placeholder = 'multiple' in this.$attrs\n            ? this.extendedSelect.placeholderMultiple : this.extendedSelect.placeholder;\n    }\n\n    $onInit(): void {\n        if (!this.deselectable && 'deselectable' in this.$attrs && !this.$attrs.deselectable.length) {\n            this.deselectable = true;\n        }\n\n        this.addOptionLang = this.extendedSelect.addOptionLang;\n        this.loadMoreResultsLang = this.extendedSelect.loadMoreResultsLang;\n        this.typeToSearchText = this.extendedSelect.typeToSearchText;\n\n        if (angular.isUndefined(this.typeToSearch)) {\n            this.typeToSearch = this.extendedSelect.typeToSearch;\n        }\n        if (angular.isUndefined(this.searchByValue)) {\n            this.searchByValue = this.extendedSelect.searchByValue;\n        }\n        if (this.multiple) {\n            this.ngModelCtrl.$isEmpty = function(value) {\n                return !value || value.length === 0;\n            };\n        }\n        this._transcludedOptions = [];\n        this.$transclude((clone) => {\n            angular.forEach(clone, (optionElement: HTMLOptionElement) => {\n                this._transcludedOptions.push({\n                    value: optionElement.value,\n                    label: optionElement.textContent\n                });\n            });\n        }, null, 'option');\n        //\n        this.$attrs.$observe('placeholder', (value) => {\n            this.placeholder = value as string;\n        });\n        this.$attrs.$observe('disabled', (value) => {\n            this.isDisabled = value === true || angular.isString(value);\n        });\n        this.$attrs.$observe('readonly', (value) => {\n            this.isReadonly = value === true || angular.isString(value);\n        });\n    }\n\n    $doCheck(): void {\n        this.isSmall = this.$element.hasClass('custom-select-sm');\n        this.isLarge = this.$element.hasClass('custom-select-lg');\n        if (this._ngOptions !== null) {\n            const optionObjects = this._ngOptions.valuesFn(this.$scope.$parent);\n            if (angular.isDefined(optionObjects) && !angular.equals(optionObjects, this._optionObjects)) {\n                this._optionObjects = angular.copy(optionObjects);\n                this.updateOptions(optionObjects);\n            }\n        }\n    }\n\n    updateOptions(optionObjects: Record<string, unknown>[]): void {\n        const options = angular.copy(this._transcludedOptions),\n            groups = [],\n            groupsTree = [],\n            addGroup = (groupName: string, parentGroup?: string) => {\n                if (angular.isDefined(parentGroup)) {\n                    addGroup(parentGroup);\n                }\n                let groupItem = groups.find((item) => {\n                    return item.name === groupName;\n                });\n\n                if (angular.isUndefined(groupItem)) {\n                    groupItem = {\n                        name: groupName,\n                        parentGroup,\n                        children: []\n                    };\n                    groups.push(groupItem);\n                } else if (angular.isDefined(parentGroup) && groupItem.parentGroup !== parentGroup) {\n                    groupItem.parentGroup = parentGroup;\n                }\n\n                return groupItem;\n            };\n        let pickLater;\n\n        optionObjects.forEach((optionObject, key) => {\n            const locals = this._ngOptions.getLocals(key, optionObject),\n                groupName = this._ngOptions.groupByFn(this.$scope.$parent, locals),\n                parentGroup = this._ngOptions.nestedByFn(this.$scope.$parent, locals);\n\n            options.push({\n                value: this._ngOptions.valueFn(this.$scope.$parent, locals),\n                label: this._ngOptions.displayFn(this.$scope.$parent, locals),\n                group: angular.isDefined(groupName) ? addGroup(groupName, parentGroup) : undefined\n            });\n\n            if (this._addOptionCalled && options[options.length - 1].label === this.search) {\n                pickLater = options[options.length - 1];\n                this._addOptionCalled = false;\n            }\n        });\n\n        if (groups.length) {\n            groups.forEach((item) => {\n                let parent, parentChildren;\n                if (angular.isUndefined(item.parentGroup)) {\n                    parentChildren = groupsTree;\n                } else {\n                    parent = groups.find((subItem) => {\n                        return subItem.name === item.parentGroup;\n                    });\n                    parentChildren = parent.children;\n                }\n                item.parent = parent;\n                parentChildren.push(item);\n            });\n            const order = [],\n                walkTree = (branch: IGroupItem[], level = 0) => {\n                    branch.forEach((item) => {\n                        order.push(item.name);\n                        item.level = level;\n                        walkTree(item.children, level + 1);\n                    });\n                }\n            walkTree(groupsTree);\n            options.sort((a, b) => {\n                return order.indexOf(a.group.name) - order.indexOf(b.group.name);\n            });\n        }\n\n        this.options = options;\n        if (pickLater) {\n            // in multiple mode, we need to wait until new option is added to this.options\n            // before selecting it\n            this.pickOption(pickLater);\n        }\n        this.filterData();\n    }\n\n    open(): void {\n        const wasOpen = this.isOpen;\n        this.ngModelCtrl.$setTouched();\n        if (this.isDisabled || this.isReadonly) {\n            this.isOpen = false;\n        } else {\n            this.isOpen = this.multiple ? true : !this.isOpen;\n        }\n        if (!wasOpen && this.isOpen) {\n            this.search = '';\n            // reset active index\n            this.activeIndex = -1;\n            this.options.some((option, i) => {\n                if (this.isSelected(option)) {\n                    this.activeIndex = i;\n                    if (!this.multiple) {\n                        return true; // break;\n                    }\n                }\n            });\n            this.filterData();\n        }\n    }\n\n    _updateMultipleModel(newValue: unknown, removeValue?: unknown): void {\n        // sort selected options, so we get same result as in select element.\n        const sorted = [];\n        this.options.forEach((option) => {\n            if (\n                (\n                    this.isSelected(option)\n                    || angular.equals(option.value, newValue)\n                )\n                && !angular.equals(option.value, removeValue)\n                && !sorted.includes(option.value)\n            ) {\n                sorted.push(option.value);\n            }\n        });\n        if (!angular.equals(this.ngModel, sorted)) {\n            this.ngModel = sorted;\n        }\n    }\n\n    filterData(): void {\n        if (angular.isUndefined(this.search)) {\n            angular.copy(this.options, this.optionsFiltered);\n            return;\n        }\n        angular.copy([], this.optionsFiltered);\n        if (this.search.length < this.typeToSearch) {\n            return;\n        }\n        const search = this.search.toLowerCase();\n        this.options.forEach((option) => {\n            if (\n                option.label.toLowerCase().includes(search)\n                || (\n                    this.searchByValue\n                    && (\n                        (\n                            angular.isString(option.value)\n                            && option.value.toLowerCase().includes(search)\n                        )\n                        || (\n                            angular.isObject(option.value)\n                            && angular.toJson(option.value).toLowerCase().includes(search)\n                        )\n                    )\n                )\n            ) {\n                this.optionsFiltered.push(option);\n            }\n        });\n    }\n\n    isSelected(option: IExtendedSelectOption): boolean {\n        if (angular.isUndefined(this.ngModel)) {\n            return false;\n        }\n        if (this.multiple) {\n            return (this.ngModel as unknown[]).includes(option.value);\n        }\n        return angular.equals(option.value, this.ngModel);\n    }\n\n    getModelLabel(value?: unknown): string {\n        if (angular.isUndefined(value)) {\n            value = this.ngModel;\n        }\n        const option = this.options.find((option) => {\n            return angular.equals(option.value, value);\n        });\n        return option ? option.label : '';\n    }\n\n    searchFn(page?: number): void {\n        if (angular.isUndefined(page)) {\n            this.activeIndex = this.options.length ? 0 : -1;\n        }\n        this.hasNextPage = false;\n        this.filterData();\n        if (angular.isFunction(this.resolveOnSearch)) {\n            this.page = page || 1;\n            if (angular.isDefined(this.search) && this.search.length) {\n                const timeout = angular.isUndefined(this._lastSearchValue) ? 0 : 750;\n                if (this._searchTimeout !== null) {\n                    this.$timeout.cancel(this._searchTimeout);\n                }\n                this._lastSearchValue = this.search;\n                this.loading = true;\n                this._searchTimeout = this.$timeout(() => {\n                    this._searchTimeout = null;\n                    this.resolveOnSearch({value: this.search, page: this.page})\n                        .then((response) => {\n                            this._lastSearchValue = undefined;\n                            this.loading = false;\n                            this.hasNextPage = response && !!response.hasNextPage;\n                            this.filterData();\n                        }).catch(angular.noop);\n                }, timeout);\n            }\n        }\n    }\n\n    pickOption(option: IExtendedSelectOption): void {\n        if (this.multiple) {\n            if (angular.isUndefined(this.ngModel)) {\n                this.ngModel = [];\n            }\n            if (!(this.ngModel as unknown[]).includes(option.value)) {\n                this._updateMultipleModel(option.value);\n            }\n            this.activeIndex = -1;\n            this.search = '';\n        } else {\n            this.isOpen = false;\n            this.ngModel = option.value;\n            this.activeIndex = this.options.indexOf(option);\n        }\n        this.hasNextPage = false;\n        this.ngModelCtrl.$setViewValue(this.ngModel);\n    }\n\n    deselect(value: unknown): void {\n        if (this.multiple) {\n            this._updateMultipleModel(undefined, value);\n        } else {\n            this.ngModel = this.deselectValue;\n        }\n        this.activeIndex = -1;\n        this.ngModelCtrl.$setViewValue(this.ngModel);\n    }\n\n    addOptionAction(): void {\n        if (angular.isFunction(this.addOption) && this.search.length) {\n            const option = this.options.find((option) => {\n                return option.label === this.search;\n            });\n            if (option) {\n                this.pickOption(option);\n            } else {\n                this.addOption({value: this.search});\n                this._addOptionCalled = true;\n                // we set this flag, so we can update ngModel with proper option,\n                // which will be generated on next digest cycle\n            }\n        }\n    }\n}\n\n/**\n * @ngdoc component\n * @name beforeOption\n */\n\n/**\n * @ngdoc component\n * @name optionTemplate\n */\n\n/**\n * @ngdoc component\n * @name extendedSelect\n *\n * @param {expression} ngModel\n * @param {expression|function} addOption\n * @param {expression|function} resolveOnSearch\n * @param {expression} deselectable\n * @param {expression|number} typeToSearch\n * @param {expression|boolean} searchByValue\n * @param {String} placeholder\n * @parma {String} multiple\n */\n\nexport const extendedSelectComponent: IComponentOptions = {\n    require: {\n        ngModelCtrl: 'ngModel'\n    },\n    bindings: {\n        ngModel: '=',\n        addOption: '&?',\n        resolveOnSearch: '&?',\n        deselectable: '<?',\n        deselectValue: '<?',\n        typeToSearch: '<?',\n        searchByValue: '<?'\n    },\n    transclude: {\n        option: '?option',\n        beforeOption: '?beforeOption',\n        optionTemplate: '?optionTemplate'\n    },\n    templateUrl: 'src/templates/extended-select.html',\n    controllerAs: 'ctrl',\n    controller: ExtendedSelectComponentController\n}\n","/*\n * AngularJS extended select component.\n * Copyright (c) 2016-2021 Rodziu <mateusz.rohde@gmail.com>\n * License: MIT\n */\nimport * as angular from 'angular';\n/**\n * @ngInject\n */\nexport class ExtendedSelectComponentController {\n    constructor($element, $attrs, $scope, $timeout, $transclude, extendedSelectOptions, extendedSelect) {\n        this.$element = $element;\n        this.$attrs = $attrs;\n        this.$scope = $scope;\n        this.$timeout = $timeout;\n        this.$transclude = $transclude;\n        this.extendedSelectOptions = extendedSelectOptions;\n        this.extendedSelect = extendedSelect;\n        //\n        this.options = [];\n        this.optionsFiltered = [];\n        this.activeIndex = -1;\n        this.search = '';\n        this._searchTimeout = null;\n        this._transcludedOptions = [];\n        this._ngOptions = 'ngOptions' in $attrs\n            ? extendedSelectOptions.parseNgOptions($attrs['ngOptions']) : null;\n        this.multiple = 'multiple' in this.$attrs;\n        this.placeholder = 'multiple' in this.$attrs\n            ? this.extendedSelect.placeholderMultiple : this.extendedSelect.placeholder;\n    }\n    $onInit() {\n        if (!this.deselectable && 'deselectable' in this.$attrs && !this.$attrs.deselectable.length) {\n            this.deselectable = true;\n        }\n        this.addOptionLang = this.extendedSelect.addOptionLang;\n        this.loadMoreResultsLang = this.extendedSelect.loadMoreResultsLang;\n        this.typeToSearchText = this.extendedSelect.typeToSearchText;\n        if (angular.isUndefined(this.typeToSearch)) {\n            this.typeToSearch = this.extendedSelect.typeToSearch;\n        }\n        if (angular.isUndefined(this.searchByValue)) {\n            this.searchByValue = this.extendedSelect.searchByValue;\n        }\n        if (this.multiple) {\n            this.ngModelCtrl.$isEmpty = function (value) {\n                return !value || value.length === 0;\n            };\n        }\n        this._transcludedOptions = [];\n        this.$transclude((clone) => {\n            angular.forEach(clone, (optionElement) => {\n                this._transcludedOptions.push({\n                    value: optionElement.value,\n                    label: optionElement.textContent\n                });\n            });\n        }, null, 'option');\n        //\n        this.$attrs.$observe('placeholder', (value) => {\n            this.placeholder = value;\n        });\n        this.$attrs.$observe('disabled', (value) => {\n            this.isDisabled = value === true || angular.isString(value);\n        });\n        this.$attrs.$observe('readonly', (value) => {\n            this.isReadonly = value === true || angular.isString(value);\n        });\n    }\n    $doCheck() {\n        this.isSmall = this.$element.hasClass('custom-select-sm');\n        this.isLarge = this.$element.hasClass('custom-select-lg');\n        if (this._ngOptions !== null) {\n            const optionObjects = this._ngOptions.valuesFn(this.$scope.$parent);\n            if (angular.isDefined(optionObjects) && !angular.equals(optionObjects, this._optionObjects)) {\n                this._optionObjects = angular.copy(optionObjects);\n                this.updateOptions(optionObjects);\n            }\n        }\n    }\n    updateOptions(optionObjects) {\n        const options = angular.copy(this._transcludedOptions), groups = [], groupsTree = [], addGroup = (groupName, parentGroup) => {\n            if (angular.isDefined(parentGroup)) {\n                addGroup(parentGroup);\n            }\n            let groupItem = groups.find((item) => {\n                return item.name === groupName;\n            });\n            if (angular.isUndefined(groupItem)) {\n                groupItem = {\n                    name: groupName,\n                    parentGroup,\n                    children: []\n                };\n                groups.push(groupItem);\n            }\n            else if (angular.isDefined(parentGroup) && groupItem.parentGroup !== parentGroup) {\n                groupItem.parentGroup = parentGroup;\n            }\n            return groupItem;\n        };\n        let pickLater;\n        optionObjects.forEach((optionObject, key) => {\n            const locals = this._ngOptions.getLocals(key, optionObject), groupName = this._ngOptions.groupByFn(this.$scope.$parent, locals), parentGroup = this._ngOptions.nestedByFn(this.$scope.$parent, locals);\n            options.push({\n                value: this._ngOptions.valueFn(this.$scope.$parent, locals),\n                label: this._ngOptions.displayFn(this.$scope.$parent, locals),\n                group: angular.isDefined(groupName) ? addGroup(groupName, parentGroup) : undefined\n            });\n            if (this._addOptionCalled && options[options.length - 1].label === this.search) {\n                pickLater = options[options.length - 1];\n                this._addOptionCalled = false;\n            }\n        });\n        if (groups.length) {\n            groups.forEach((item) => {\n                let parent, parentChildren;\n                if (angular.isUndefined(item.parentGroup)) {\n                    parentChildren = groupsTree;\n                }\n                else {\n                    parent = groups.find((subItem) => {\n                        return subItem.name === item.parentGroup;\n                    });\n                    parentChildren = parent.children;\n                }\n                item.parent = parent;\n                parentChildren.push(item);\n            });\n            const order = [], walkTree = (branch, level = 0) => {\n                branch.forEach((item) => {\n                    order.push(item.name);\n                    item.level = level;\n                    walkTree(item.children, level + 1);\n                });\n            };\n            walkTree(groupsTree);\n            options.sort((a, b) => {\n                return order.indexOf(a.group.name) - order.indexOf(b.group.name);\n            });\n        }\n        this.options = options;\n        if (pickLater) {\n            // in multiple mode, we need to wait until new option is added to this.options\n            // before selecting it\n            this.pickOption(pickLater);\n        }\n        this.filterData();\n    }\n    open() {\n        const wasOpen = this.isOpen;\n        this.ngModelCtrl.$setTouched();\n        if (this.isDisabled || this.isReadonly) {\n            this.isOpen = false;\n        }\n        else {\n            this.isOpen = this.multiple ? true : !this.isOpen;\n        }\n        if (!wasOpen && this.isOpen) {\n            this.search = '';\n            // reset active index\n            this.activeIndex = -1;\n            this.options.some((option, i) => {\n                if (this.isSelected(option)) {\n                    this.activeIndex = i;\n                    if (!this.multiple) {\n                        return true; // break;\n                    }\n                }\n            });\n            this.filterData();\n        }\n    }\n    _updateMultipleModel(newValue, removeValue) {\n        // sort selected options, so we get same result as in select element.\n        const sorted = [];\n        this.options.forEach((option) => {\n            if ((this.isSelected(option)\n                || angular.equals(option.value, newValue))\n                && !angular.equals(option.value, removeValue)\n                && !sorted.includes(option.value)) {\n                sorted.push(option.value);\n            }\n        });\n        if (!angular.equals(this.ngModel, sorted)) {\n            this.ngModel = sorted;\n        }\n    }\n    filterData() {\n        if (angular.isUndefined(this.search)) {\n            angular.copy(this.options, this.optionsFiltered);\n            return;\n        }\n        angular.copy([], this.optionsFiltered);\n        if (this.search.length < this.typeToSearch) {\n            return;\n        }\n        const search = this.search.toLowerCase();\n        this.options.forEach((option) => {\n            if (option.label.toLowerCase().includes(search)\n                || (this.searchByValue\n                    && ((angular.isString(option.value)\n                        && option.value.toLowerCase().includes(search))\n                        || (angular.isObject(option.value)\n                            && angular.toJson(option.value).toLowerCase().includes(search))))) {\n                this.optionsFiltered.push(option);\n            }\n        });\n    }\n    isSelected(option) {\n        if (angular.isUndefined(this.ngModel)) {\n            return false;\n        }\n        if (this.multiple) {\n            return this.ngModel.includes(option.value);\n        }\n        return angular.equals(option.value, this.ngModel);\n    }\n    getModelLabel(value) {\n        if (angular.isUndefined(value)) {\n            value = this.ngModel;\n        }\n        const option = this.options.find((option) => {\n            return angular.equals(option.value, value);\n        });\n        return option ? option.label : '';\n    }\n    searchFn(page) {\n        if (angular.isUndefined(page)) {\n            this.activeIndex = this.options.length ? 0 : -1;\n        }\n        this.hasNextPage = false;\n        this.filterData();\n        if (angular.isFunction(this.resolveOnSearch)) {\n            this.page = page || 1;\n            if (angular.isDefined(this.search) && this.search.length) {\n                const timeout = angular.isUndefined(this._lastSearchValue) ? 0 : 750;\n                if (this._searchTimeout !== null) {\n                    this.$timeout.cancel(this._searchTimeout);\n                }\n                this._lastSearchValue = this.search;\n                this.loading = true;\n                this._searchTimeout = this.$timeout(() => {\n                    this._searchTimeout = null;\n                    this.resolveOnSearch({ value: this.search, page: this.page })\n                        .then((response) => {\n                        this._lastSearchValue = undefined;\n                        this.loading = false;\n                        this.hasNextPage = response && !!response.hasNextPage;\n                        this.filterData();\n                    }).catch(angular.noop);\n                }, timeout);\n            }\n        }\n    }\n    pickOption(option) {\n        if (this.multiple) {\n            if (angular.isUndefined(this.ngModel)) {\n                this.ngModel = [];\n            }\n            if (!this.ngModel.includes(option.value)) {\n                this._updateMultipleModel(option.value);\n            }\n            this.activeIndex = -1;\n            this.search = '';\n        }\n        else {\n            this.isOpen = false;\n            this.ngModel = option.value;\n            this.activeIndex = this.options.indexOf(option);\n        }\n        this.hasNextPage = false;\n        this.ngModelCtrl.$setViewValue(this.ngModel);\n    }\n    deselect(value) {\n        if (this.multiple) {\n            this._updateMultipleModel(undefined, value);\n        }\n        else {\n            this.ngModel = this.deselectValue;\n        }\n        this.activeIndex = -1;\n        this.ngModelCtrl.$setViewValue(this.ngModel);\n    }\n    addOptionAction() {\n        if (angular.isFunction(this.addOption) && this.search.length) {\n            const option = this.options.find((option) => {\n                return option.label === this.search;\n            });\n            if (option) {\n                this.pickOption(option);\n            }\n            else {\n                this.addOption({ value: this.search });\n                this._addOptionCalled = true;\n                // we set this flag, so we can update ngModel with proper option,\n                // which will be generated on next digest cycle\n            }\n        }\n    }\n}\n/**\n * @ngdoc component\n * @name beforeOption\n */\n/**\n * @ngdoc component\n * @name optionTemplate\n */\n/**\n * @ngdoc component\n * @name extendedSelect\n *\n * @param {expression} ngModel\n * @param {expression|function} addOption\n * @param {expression|function} resolveOnSearch\n * @param {expression} deselectable\n * @param {expression|number} typeToSearch\n * @param {expression|boolean} searchByValue\n * @param {String} placeholder\n * @parma {String} multiple\n */\nexport const extendedSelectComponent = {\n    require: {\n        ngModelCtrl: 'ngModel'\n    },\n    bindings: {\n        ngModel: '=',\n        addOption: '&?',\n        resolveOnSearch: '&?',\n        deselectable: '<?',\n        deselectValue: '<?',\n        typeToSearch: '<?',\n        searchByValue: '<?'\n    },\n    transclude: {\n        option: '?option',\n        beforeOption: '?beforeOption',\n        optionTemplate: '?optionTemplate'\n    },\n    templateUrl: 'src/templates/extended-select.html',\n    controllerAs: 'ctrl',\n    controller: ExtendedSelectComponentController\n};\n","/*\n * AngularJS extended select component.\n * Copyright (c) 2016-2021 Rodziu <mateusz.rohde@gmail.com>\n * License: MIT\n */\n\nimport IProvideService = angular.auto.IProvideService;\nimport * as angular from 'angular';\nimport {IDirective} from 'angular';\n\n/**\n * Prevent ng-options directive from compiling on angular-extended-select\n * @ngInject\n */\nexport function extendedSelectConfig($provide: IProvideService): void {\n    const blocked = ['ngOptions', 'select'];\n    angular.forEach(blocked, function(directiveName) {\n        $provide.decorator(directiveName + 'Directive', ['$delegate', function($delegate) {\n            angular.forEach($delegate, function(directive: IDirective) {\n                const compile_ = directive.compile || angular.noop;\n                directive.compile = function(element, attrs, transclude) {\n                    if (element[0].tagName === 'EXTENDED-SELECT') {\n                        directive.terminal = false;\n                        return;\n                    }\n                    return compile_.apply(this, [element, attrs, transclude]) || directive.link;\n                };\n            });\n            return $delegate;\n        }]);\n    });\n}\n","/*\n * AngularJS extended select component.\n * Copyright (c) 2016-2021 Rodziu <mateusz.rohde@gmail.com>\n * License: MIT\n */\nimport * as angular from 'angular';\n/**\n * Prevent ng-options directive from compiling on angular-extended-select\n * @ngInject\n */\nexport function extendedSelectConfig($provide) {\n    const blocked = ['ngOptions', 'select'];\n    angular.forEach(blocked, function (directiveName) {\n        $provide.decorator(directiveName + 'Directive', ['$delegate', function ($delegate) {\n                angular.forEach($delegate, function (directive) {\n                    const compile_ = directive.compile || angular.noop;\n                    directive.compile = function (element, attrs, transclude) {\n                        if (element[0].tagName === 'EXTENDED-SELECT') {\n                            directive.terminal = false;\n                            return;\n                        }\n                        return compile_.apply(this, [element, attrs, transclude]) || directive.link;\n                    };\n                });\n                return $delegate;\n            }]);\n    });\n}\n","/*\n * AngularJS extended select component.\n * Copyright (c) 2016-2021 Rodziu <mateusz.rohde@gmail.com>\n * License: MIT\n */\n\nimport * as angular from 'angular';\nimport angularBS from 'angularjs-bootstrap-4';\nimport {ExtendedSelectProvider} from './extended-select.provider';\nimport {extendedSelectConfig} from './extended-select.config';\nimport {ExtendedSelectOptionsService} from './service/extended-select-options.service';\nimport {extendedSelectComponent} from './component/extended-select.component';\nimport {esTranscludeDirective} from './component/es-transclude.directive';\nimport {extendedSelectMarkResultComponent} from './component/extended-select-mark-result.component';\nimport {extendedSelectOptionGroupComponent} from './component/extended-select-option-group.component';\nimport {extendedSelectOptionsDirective} from './component/extended-select-options.directive';\nimport {extendedSelectSearchDirective} from './component/extended-select-search.directive';\n\nconst extendedSelectModule = angular.module('extendedSelect', [angularBS])\n    .provider('extendedSelect', ExtendedSelectProvider)\n    .config(extendedSelectConfig)\n    .factory('extendedSelectOptions', ExtendedSelectOptionsService)\n    .component('extendedSelect', extendedSelectComponent)\n    .directive('esTransclude', esTranscludeDirective)\n    .component('extendedSelectMarkResult', extendedSelectMarkResultComponent)\n    .component('extendedSelectOptionGroup', extendedSelectOptionGroupComponent)\n    .directive('extendedSelectOptions', extendedSelectOptionsDirective)\n    .directive('extendedSelectSearch', extendedSelectSearchDirective);\n\nexport const extendedSelect = extendedSelectModule.name;\n","/*\n * AngularJS extended select component.\n * Copyright (c) 2016-2021 Rodziu <mateusz.rohde@gmail.com>\n * License: MIT\n */\nimport * as angular from 'angular';\nimport angularBS from 'angularjs-bootstrap-4';\nimport { ExtendedSelectProvider } from './extended-select.provider';\nimport { extendedSelectConfig } from './extended-select.config';\nimport { ExtendedSelectOptionsService } from './service/extended-select-options.service';\nimport { extendedSelectComponent } from './component/extended-select.component';\nimport { esTranscludeDirective } from './component/es-transclude.directive';\nimport { extendedSelectMarkResultComponent } from './component/extended-select-mark-result.component';\nimport { extendedSelectOptionGroupComponent } from './component/extended-select-option-group.component';\nimport { extendedSelectOptionsDirective } from './component/extended-select-options.directive';\nimport { extendedSelectSearchDirective } from './component/extended-select-search.directive';\nconst extendedSelectModule = angular.module('extendedSelect', [angularBS])\n    .provider('extendedSelect', ExtendedSelectProvider)\n    .config(extendedSelectConfig)\n    .factory('extendedSelectOptions', ExtendedSelectOptionsService)\n    .component('extendedSelect', extendedSelectComponent)\n    .directive('esTransclude', esTranscludeDirective)\n    .component('extendedSelectMarkResult', extendedSelectMarkResultComponent)\n    .component('extendedSelectOptionGroup', extendedSelectOptionGroupComponent)\n    .directive('extendedSelectOptions', extendedSelectOptionsDirective)\n    .directive('extendedSelectSearch', extendedSelectSearchDirective);\nexport const extendedSelect = extendedSelectModule.name;\n","/*\n * AngularJS extended select component.\n * Copyright (c) 2016-2021 Rodziu <mateusz.rohde@gmail.com>\n * License: MIT\n */\n\nexport interface IExtendedSelectOptions {\n    placeholder: string,\n    placeholderMultiple: string,\n    typeToSearch: number,\n    typeToSearchText: string,\n    addOptionLang: string,\n    loadMoreResultsLang: string,\n    searchByValue: boolean\n}\n\nexport class ExtendedSelectProvider {\n    options: IExtendedSelectOptions = {\n        placeholder: '\\u00A0',\n        placeholderMultiple: '\\u00A0',\n        typeToSearch: 0,\n        typeToSearchText: 'Begin typing to display available options',\n        addOptionLang: 'Add',\n        loadMoreResultsLang: 'Load more results',\n        searchByValue: false\n    }\n\n    $get(): IExtendedSelectOptions {\n        return this.options;\n    }\n}\n","/*\n * AngularJS extended select component.\n * Copyright (c) 2016-2021 Rodziu <mateusz.rohde@gmail.com>\n * License: MIT\n */\nexport class ExtendedSelectProvider {\n    constructor() {\n        this.options = {\n            placeholder: '\\u00A0',\n            placeholderMultiple: '\\u00A0',\n            typeToSearch: 0,\n            typeToSearchText: 'Begin typing to display available options',\n            addOptionLang: 'Add',\n            loadMoreResultsLang: 'Load more results',\n            searchByValue: false\n        };\n    }\n    $get() {\n        return this.options;\n    }\n}\n","/*\n * AngularJS extended select component.\n * Copyright (c) 2016-2021 Rodziu <mateusz.rohde@gmail.com>\n * License: MIT\n */\nimport {ICompiledExpression, IParseService} from 'angular';\n\n/**\n * Parse ng-options in angular way.\n * 1: value expression (valueFn)\n * 2: label expression (displayFn)\n * 3: group by expression (groupByFn)\n * 4: nested by expression (nestedByFn)\n * 5: disable when expression (disableWhenFn)\n * 6: array item variable name\n * 7: object item key variable name\n * 8: object item value variable name\n * 9: collection expression\n * 10: track by expression\n * @type {RegExp}\n */\n// eslint-disable-next-line max-len\nconst NG_OPTIONS_REGEXP = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?(?:\\s+group\\s+by\\s+([\\s\\S]+?)(?:\\s+nested\\s+by\\s+([\\s\\S]+?))?)?(?:\\s+disable\\s+when\\s+([\\s\\S]+?))?\\s+for\\s+(?:([$\\w][$\\w]*)|(?:\\(\\s*([$\\w][$\\w]*)\\s*,\\s*([$\\w][$\\w]*)\\s*\\)))\\s+in\\s+([\\s\\S]+?)(?:\\s+track\\s+by\\s+([\\s\\S]+?))?$/;\n\nexport interface IParsedNgOptions {\n    valueFn: ICompiledExpression,\n    displayFn: ICompiledExpression,\n    groupByFn: ICompiledExpression,\n    nestedByFn: ICompiledExpression,\n    valuesFn: ICompiledExpression,\n    getLocals: (key: unknown, value: unknown) => Record<string, unknown>\n}\n\n/**\n * @ngInject\n */\nexport class ExtendedSelectOptionsService {\n    constructor(\n        private $parse: IParseService\n    ) {\n    }\n\n    parseNgOptions(ngOptionsString: string): IParsedNgOptions {\n        const match = ngOptionsString.match(NG_OPTIONS_REGEXP);\n        if (match === null) {\n            return null;\n        }\n        const valueName = match[6] || match[8],\n            keyName = match[7];\n        return {\n            valueFn: this.$parse(match[2] ? match[1] : valueName),\n            displayFn: this.$parse(match[2] || match[1]),\n            groupByFn: this.$parse(match[3] || ''),\n            nestedByFn: this.$parse(match[4] || ''),\n            valuesFn: this.$parse(match[9]),\n            getLocals: (key, value) => {\n                const locals = {};\n                locals[valueName] = value;\n                if (keyName) {\n                    locals[keyName] = key;\n                }\n                return locals;\n            }\n        };\n    }\n}\n","/**\n * Parse ng-options in angular way.\n * 1: value expression (valueFn)\n * 2: label expression (displayFn)\n * 3: group by expression (groupByFn)\n * 4: nested by expression (nestedByFn)\n * 5: disable when expression (disableWhenFn)\n * 6: array item variable name\n * 7: object item key variable name\n * 8: object item value variable name\n * 9: collection expression\n * 10: track by expression\n * @type {RegExp}\n */\n// eslint-disable-next-line max-len\nconst NG_OPTIONS_REGEXP = /^\\s*([\\s\\S]+?)(?:\\s+as\\s+([\\s\\S]+?))?(?:\\s+group\\s+by\\s+([\\s\\S]+?)(?:\\s+nested\\s+by\\s+([\\s\\S]+?))?)?(?:\\s+disable\\s+when\\s+([\\s\\S]+?))?\\s+for\\s+(?:([$\\w][$\\w]*)|(?:\\(\\s*([$\\w][$\\w]*)\\s*,\\s*([$\\w][$\\w]*)\\s*\\)))\\s+in\\s+([\\s\\S]+?)(?:\\s+track\\s+by\\s+([\\s\\S]+?))?$/;\n/**\n * @ngInject\n */\nexport class ExtendedSelectOptionsService {\n    constructor($parse) {\n        this.$parse = $parse;\n    }\n    parseNgOptions(ngOptionsString) {\n        const match = ngOptionsString.match(NG_OPTIONS_REGEXP);\n        if (match === null) {\n            return null;\n        }\n        const valueName = match[6] || match[8], keyName = match[7];\n        return {\n            valueFn: this.$parse(match[2] ? match[1] : valueName),\n            displayFn: this.$parse(match[2] || match[1]),\n            groupByFn: this.$parse(match[3] || ''),\n            nestedByFn: this.$parse(match[4] || ''),\n            valuesFn: this.$parse(match[9]),\n            getLocals: (key, value) => {\n                const locals = {};\n                locals[valueName] = value;\n                if (keyName) {\n                    locals[keyName] = key;\n                }\n                return locals;\n            }\n        };\n    }\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE_angular__;","module.exports = __WEBPACK_EXTERNAL_MODULE_angularjs_bootstrap_4__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/*\n * AngularJS extended select component.\n * Copyright (c) 2016-2021 Rodziu <mateusz.rohde@gmail.com>\n * License: MIT\n */\n\nimport {extendedSelect} from './lib/extended-select.module';\nexport {ExtendedSelectOptionsService} from './lib/service/extended-select-options.service';\nexport {IExtendedSelectOptions} from './lib/extended-select.provider';\n\nexport default extendedSelect;\n","/*\n * AngularJS extended select component.\n * Copyright (c) 2016-2021 Rodziu <mateusz.rohde@gmail.com>\n * License: MIT\n */\nimport { extendedSelect } from './lib/extended-select.module';\nexport { ExtendedSelectOptionsService } from './lib/service/extended-select-options.service';\nexport default extendedSelect;\n"],"sourceRoot":""}